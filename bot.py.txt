import telebot
import sqlite3
from datetime import datetime, timedelta
import pytz
from telebot import types
import threading
import time
import logging

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#   ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

API_TOKEN = 'Ğ’ĞĞ¨_Ğ¢ĞĞšĞ•Ğ_Ğ‘ĞĞ¢Ğ_Ğ—Ğ”Ğ•Ğ¡Ğ¬'  # â† Ğ’Ğ¡Ğ¢ĞĞ’Ğ¬ Ğ¡Ğ’ĞĞ™ Ğ¢ĞĞšĞ•Ğ
ADMIN_ID = 634320645
GROUP_LINK = "https://t.me/+rd1Y4siYtlA2NjIy"

ASTANA_TZ = pytz.timezone('Asia/Almaty')
DAILY_SEND_HOUR = 10
DAILY_SEND_MINUTE = 0

PAYMENT_URL = "https://your-payment-link.example.com/course"  # â† Ğ’Ğ¡Ğ¢ĞĞ’Ğ¬ Ğ¡Ğ’ĞĞ® Ğ¡Ğ¡Ğ«Ğ›ĞšĞ£ ĞĞ ĞĞŸĞ›ĞĞ¢Ğ£

import content  # Ñ„Ğ°Ğ¹Ğ» content.py Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ Ğ² Ñ‚Ğ¾Ğ¹ Ğ¶Ğµ Ğ¿Ğ°Ğ¿ĞºĞµ

bot = telebot.TeleBot(API_TOKEN)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#   Ğ‘Ğ°Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def init_db():
    conn = sqlite3.connect('mama_i_ya.db', check_same_thread=False)
    c = conn.cursor()
    c.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            first_name TEXT,
            joined_at TEXT,
            current_day INTEGER DEFAULT 0,
            paid_until TEXT,
            last_sent_date TEXT
        )
    ''')
    conn.commit()
    return conn

db_conn = init_db()

def get_user(user_id):
    c = db_conn.cursor()
    c.execute("SELECT * FROM users WHERE user_id = ?", (user_id,))
    row = c.fetchone()
    if row:
        keys = ['user_id', 'username', 'first_name', 'joined_at', 
                'current_day', 'paid_until', 'last_sent_date']
        return dict(zip(keys, row))
    return None

def register_user(message):
    user_id = message.from_user.id
    if get_user(user_id):
        return False

    c = db_conn.cursor()
    now = datetime.now(ASTANA_TZ).isoformat()
    c.execute('''
        INSERT INTO users 
        (user_id, username, first_name, joined_at, current_day)
        VALUES (?, ?, ?, ?, 0)
    ''', (
        user_id,
        message.from_user.username,
        message.from_user.first_name,
        now
    ))
    db_conn.commit()
    return True

def update_user_day(user_id, new_day):
    c = db_conn.cursor()
    c.execute("UPDATE users SET current_day = ? WHERE user_id = ?", (new_day, user_id))
    db_conn.commit()

def mark_day_sent(user_id):
    today = datetime.now(ASTANA_TZ).date().isoformat()
    c = db_conn.cursor()
    c.execute("UPDATE users SET last_sent_date = ? WHERE user_id = ?", (today, user_id))
    db_conn.commit()

def can_send_today(user_id):
    user = get_user(user_id)
    if not user:
        return False
    today = datetime.now(ASTANA_TZ).date().isoformat()
    return user['last_sent_date'] != today

def is_paid_or_trial(user):
    if user['current_day'] < 7:
        return True  # Ğ¿ĞµÑ€Ğ²Ğ°Ñ Ğ½ĞµĞ´ĞµĞ»Ñ Ğ±ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ğ°Ñ
    if not user['paid_until']:
        return False
    paid_until = datetime.fromisoformat(user['paid_until']).date()
    return datetime.now(ASTANA_TZ).date() <= paid_until

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#   Ğ¢ĞµĞºÑÑ‚ Ğ·Ğ°Ğ´Ğ°Ğ½Ğ¸Ñ
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def get_task_text(day: int) -> str:
    if day < 1 or day not in content.TASKS:
        return "Ğ—Ğ°Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ° ÑÑ‚Ğ¾Ñ‚ Ğ´ĞµĞ½ÑŒ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾ ğŸ«¶\nĞĞ°Ğ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ /start Ğ¸Ğ»Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ¸Ñ‚ĞµÑÑŒ Ğº @admin"
    
    task = content.TASKS[day]
    text = f"âœ¨ {task['title']}\n\n{task['content']}\n\n"
    
    if day == 7:
        text += "\nĞŸĞ¾Ğ·Ğ´Ñ€Ğ°Ğ²Ğ»ÑÑ! Ğ’Ñ‹ Ğ¿Ñ€Ğ¾ÑˆĞ»Ğ¸ Ğ¿ĞµÑ€Ğ²ÑƒÑ Ğ±ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½ÑƒÑ Ğ½ĞµĞ´ĞµĞ»Ñ! ğŸ‰\n\n"
        text += content.PAYMENT_MESSAGE.replace("Ğ¡ÑÑ‹Ğ»ĞºĞ° Ğ´Ğ»Ñ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹ ğŸ‘‡", f"[ĞĞ¿Ğ»Ğ°Ñ‚Ğ¸Ñ‚ÑŒ Ğ¸ Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ â†’]({PAYMENT_URL})")
    elif day == 30:
        text += "\n" + content.FINAL_MESSAGE
    
    return text

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#   ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@bot.message_handler(commands=['start'])
def start(message):
    user_id = message.from_user.id
    new_user = register_user(message)
    
    markup = types.InlineKeyboardMarkup(row_width=1)
    markup.add(types.InlineKeyboardButton("ğŸ’¬ Ğ§Ğ°Ñ‚ Ğ´Ğ»Ñ Ñ€Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹", url=GROUP_LINK))
    
    user = get_user(user_id)
    if user and user['current_day'] >= 1:
        markup.add(types.InlineKeyboardButton("â†’ ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ Ñ ÑĞµĞ³Ğ¾Ğ´Ğ½ÑÑˆĞ½ĞµĞ³Ğ¾ Ğ´Ğ½Ñ", callback_data="send_today"))
    else:
        markup.add(types.InlineKeyboardButton("ğŸš€ ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ 1-Ğ¹ Ğ´ĞµĞ½ÑŒ", callback_data="start_day_1"))
    
    text = content.WELCOME_TEXT
    if not new_user:
        text = "Ğ Ğ°Ğ´Ğ°, Ñ‡Ñ‚Ğ¾ Ğ²Ñ‹ Ğ²ĞµÑ€Ğ½ÑƒĞ»Ğ¸ÑÑŒ! ğŸ«¶\n\n" + text.split("Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ")[1]
    
    bot.send_message(message.chat.id, text, reply_markup=markup, parse_mode='Markdown')

@bot.callback_query_handler(func=lambda call: True)
def callback_handler(call):
    user_id = call.from_user.id
    chat_id = call.message.chat.id
    
    if call.data == "start_day_1":
        user = get_user(user_id)
        if not user or user['current_day'] == 0:
            update_user_day(user_id, 1)
        bot.send_message(chat_id, get_task_text(1), parse_mode='Markdown')
        bot.answer_callback_query(call.id, "ĞĞ°Ñ‡Ğ¸Ğ½Ğ°ĞµĞ¼! Ğ”ĞµĞ½ÑŒ 1 ÑƒĞ¶Ğµ Ñƒ Ğ²Ğ°Ñ âœ¨")
    
    elif call.data == "send_today":
        user = get_user(user_id)
        if not user:
            bot.answer_callback_query(call.id, "Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° /start", show_alert=True)
            return
        
        day = user['current_day']
        if day == 0:
            day = 1
            update_user_day(user_id, 1)
        
        if not can_send_today(user_id):
            bot.answer_callback_query(call.id, "Ğ—Ğ°Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ° ÑĞµĞ³Ğ¾Ğ´Ğ½Ñ ÑƒĞ¶Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾", show_alert=True)
            return
        
        if not is_paid_or_trial(user) and day >= 8:
            bot.send_message(chat_id, content.PAYMENT_MESSAGE.replace("Ğ¡ÑÑ‹Ğ»ĞºĞ° Ğ´Ğ»Ñ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹ ğŸ‘‡", f"[ĞĞ¿Ğ»Ğ°Ñ‚Ğ¸Ñ‚ÑŒ Ğ¸ Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ â†’]({PAYMENT_URL})"), parse_mode='Markdown')
            bot.answer_callback_query(call.id)
            return
        
        text = get_task_text(day)
        bot.send_message(chat_id, text, parse_mode='Markdown')
        mark_day_sent(user_id)
        if day < 30:
            update_user_day(user_id, day + 1)
        bot.answer_callback_query(call.id, f"Ğ”ĞµĞ½ÑŒ {day} Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½!")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#   Ğ•Ğ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ğ°Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ°
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def daily_sender():
    while True:
        now = datetime.now(ASTANA_TZ)
        target = now.replace(hour=DAILY_SEND_HOUR, minute=DAILY_SEND_MINUTE, second=0, microsecond=0)
        
        if now > target:
            target += timedelta(days=1)
        
        seconds_to_wait = (target - now).total_seconds()
        logger.info(f"Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ°Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ° Ñ‡ĞµÑ€ĞµĞ· {seconds_to_wait//60:.0f} Ğ¼Ğ¸Ğ½ÑƒÑ‚")
        time.sleep(seconds_to_wait)
        
        c = db_conn.cursor()
        c.execute("SELECT user_id, current_day, paid_until FROM users WHERE current_day > 0")
        users = c.fetchall()
        
        for uid, day, paid_until in users:
            try:
                if not can_send_today(uid):
                    continue
                
                if day >= 8 and not paid_until:
                    continue
                
                if day > 0 and is_paid_or_trial({'current_day': day, 'paid_until': paid_until}):
                    text = get_task_text(day)
                    bot.send_message(uid, text, parse_mode='Markdown')
                    mark_day_sent(uid)
                    if day < 30:
                        update_user_day(uid, day + 1)
                    logger.info(f"ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ Ğ·Ğ°Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ´Ğ½Ñ {day} â†’ {uid}")
                    
            except Exception as e:
                logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞµ {uid}: {e}")
        
        time.sleep(60)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#   Ğ—Ğ°Ğ¿ÑƒÑĞº
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if __name__ == '__main__':
    threading.Thread(target=daily_sender, daemon=True).start()
    logger.info("Ğ‘Ğ¾Ñ‚ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½. ĞĞ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹...")
    bot.infinity_polling(timeout=25, long_polling_timeout=20)